
At the core of every StaticFrame Index is an AutoMap (or the immutable FrozenAutoMap), a custom dictionary-like container implemented as a C-extension (originally by our former colleague Brandt Bucher). This container meets the special needs of Index objects: given a sequence of hashable labels, permit obtaining their position with near constant-time performance. This can be done with standard dicts: given a sequence of hashables (seq) we could do the following: {k: v for v, k in enumerate(seq)}. This is inefficient, however, in that they values are always just contiguous integers; duplicating them for every dictionary is unnecessary. The first implementation optimized this aspect by using a shared cache of contiguous integers. In addition, that first implementation used a novel hash-table collision scanning approach to take advantage of contiguous memory. While this permited creating AutoMap's in about half the time as normal dicts, that performance was only available when starting with a list of Python objects. As every StaticFrame Index stores an immutable array of labels, converting that array to a list was costly and significantly reduced the performance advantage. Even more, the opportunity of just holding a reference to the immutable array was not taken, missing out on performance and memory savings. Over the past few weeks I have extended FrozenAutoMap to work directly with immutable arrays, holding on to them without copy, and using their C-types directly for hashing and lookup comparison. In most cases, particularly at scale, FrozenAutoMap, given an immutable array of non-object types, now outperforms any AutoMap created from a list. This offers a potentially significant general performance improvement throughout StaticFrame.



AutoMap

A specialized dictionary where keys and their ordering are the only thing that matters

A key points to an integer; we want constant-time lookup from a key to its ordered position.

Original AutoMap:

    Took arbitrary iterables and loaded them into an internally managed List

    The "hash table" is an array of structs, where each item is a pair of hash code and the index into keys list to find the key

    Hashing used PyObject_Hash
    Comparison to other objects used PyObject_RichCompareBool

    On insert, we compute a hash, and lookup hash in the table; we search the table until we find an empty position.

    On lookup, we compute a hash and map it to a table_pos; fetching this table position, we see if the hash matches; if so, we fetch the key and compare it; if not a match (or if hashes do not match), we continue searching the table.

    Brandt's original implementation used a sequential scan when possible to optimize performance.


Problems with Arrays.

    For every SF index, there is an immutable NumPy array of labels.

    When creating an FrozenAutoMap from an array, those values would be extracted as Scalars into a list.

    It was discovered that for most types, calling `tolist()` first was faster than letting FAM iterate the array and create a list. This created a whole list that was thrown away.

    The goal of using immutable arrays is no-copy reuse. How can we use this in a FAM?

    For AutoMap (mutable), we can continue to use a list


NumPy Arrays

    A PyObject that wraps (sometimes) contiguous byte data interpreted (with a dtype and strides) as a N-dimensional array data.

    There are two ways to get elements out of an array:
        as a PyObject
        as a Scalar
        Calling `tolist()` creates PyObjects
        Selection & iteration result in Scalars

    The performance advantage of NumPy is using the byte data and C-types directly, avoiding Py Objects


First Approach

    Store immutable array instead of keys list (no-copy)

    For insertion and hashing, use PyArray_GETITEM to get a PyObject

    For lookup, use PyArray_GETITEM to get a PyObject, then use PyObject_RichCompare

    Performance was not improved (memory might have been)

    Using PyArray_ToScalar was slower.

    Problem: still have to create a PyObject for every element on initialization and lookup.


Second Approach

    Identify arrays on initialization

    On insert, read C-type from byte-data and pass it to type-specific insertion function.

        If array is contiguous, can do sequential access after extracting PyArray_DATA

        If not, can use PyArray_GETPTR1

    Type-specific insertion can use type-specific hash function (no PyObjects).

    Type-specific lookup can compare a foreign key (as a C type) to value in the array (extracted with PyArray_GETPTR1)

    Generic lookup routines know the type of the stored array: can reject foreign keys by type, before hashing

    Given Scalars, can extract data.

    Given PyObjects, can convert to C-types for type-specific loookup.


Performance

    NumPy unicode arrays had particularly bad performance


Limitations:

    Floats of less then 64 bit are sometimes not recoverable.

    >>> import numpy as np
    >>> a1 = np.array((2.3, 5.4), dtype=np.float32)
    >>> d = {k: v for v, k in enumerate(a1)}
    >>> d
    {2.3: 0, 5.4: 1}
    >>> d[5.4]
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    KeyError: 5.4
    >>> d[a1[1]]
    1
    >>> d[a1[0]]
    0
    >>> d[2.3]
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    KeyError: 2.3

    >>> from automap import AutoMap
    >>> am = AutoMap(a1)
    >>> am
    automap.AutoMap([2.299999952316284, 5.400000095367432])
    >>> am[a1[1]]
    1
    >>> am[a1[0]]
    0


Can try to use the following:

https://numpy.org/doc/stable/reference/c-api/array.html#c.PyArray_ScalarAsCtype

PyArray_ScalarAsCtype
PyArray_CastScalarToCtype


The C-names for these types are Py{TYPE}ArrType_Type where {TYPE} can be

    Bool, Byte, Short, Int, Long, LongLong, UByte, UShort, UInt, ULong, ULongLong, Half, Float, Double, LongDouble, CFloat, CDouble, CLongDouble, String, Unicode, Void, and Object.


These type names are part of the C-API and can therefore be created in extension C-code. There is also a PyIntpArrType_Type and a PyUIntpArrType_Type that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function PyArray_ScalarAsCtype (..) can be used to extract the C-type value from the array scalar and the function PyArray_Scalar (â€¦) can be used to construct an array scalar from a C-value.








